# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.1)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
point.in.hull<-sapply(1:length(sol), function(k)
geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
return(list(sum(point.in.hull)/length(point.in.hull), valid.point)  )
})
# ## KC DATA
#
# kc <- read.csv("C:/Users/paolo/OneDrive - Politecnico di Milano/Università/Tesi/Cqr Compare Dataset/datasets/kc_house_data.csv")
# kc=kc[,-c(1,2)]
# y=kc[,c(1,4)]
# x=kc[,-c(1,4,16,17)]
# x=x[,-c(3,9,10,14,15)]
it<-pbapply::pbsapply(1:2, function(ss){
##
set.seed(ss^2)
# n=300
# p=4
# q=2
# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.1)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
#
#  point.in.hull<-sapply(1:length(sol), function(k)
#    geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
#
return(valid.point)
})
devtools::load_all(".")
# ## KC DATA
#
# kc <- read.csv("C:/Users/paolo/OneDrive - Politecnico di Milano/Università/Tesi/Cqr Compare Dataset/datasets/kc_house_data.csv")
# kc=kc[,-c(1,2)]
# y=kc[,c(1,4)]
# x=kc[,-c(1,4,16,17)]
# x=x[,-c(3,9,10,14,15)]
it<-pbapply::pbsapply(1:2, function(ss){
##
set.seed(ss^2)
# n=300
# p=4
# q=2
# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.1)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
#
#  point.in.hull<-sapply(1:length(sol), function(k)
#    geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
#
return(valid.point)
})
it
it<-pbapply::pbsapply(1:10, function(ss){
##
set.seed(ss^2)
# n=300
# p=4
# q=2
# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.1)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
#
#  point.in.hull<-sapply(1:length(sol), function(k)
#    geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
#
return(valid.point)
})
it
mean(it)
it<-pbapply::pbsapply(1:3, function(ss){
##
set.seed(ss^2)
# n=300
# p=4
# q=2
# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.2)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
#
#  point.in.hull<-sapply(1:length(sol), function(k)
#    geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
#
return(valid.point)
})
it
mean(it)
it<-pbapply::pbsapply(1:3, function(ss){
##
set.seed(ss^2)
# n=300
# p=4
# q=2
# mu=rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# y<-t(sapply(1:n, function(i) c(5 + 7*exp(x[i,1]) -2*sin(x[i,2]) +0.5*x[i,3] - 2.2*cos(x[i,4])+3*x[i,5], 0.2 + 2*exp(0.2*x[i,1]) -2*sin(6.6*x[i,2]) +0.003*x[i,3] - 2.2*cos(3.3*x[i,4])-3*x[i,5] )))
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.05)
n0<-nrow(y0)
sol2<-lapply(1:n0, function(u) t(cbind(apply(sol[[u]],2,min), apply(sol[[u]],2,max))))
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol2[[u]][1,j] <= y0[u,j] && sol2[[u]][2,j] >= y0[u,j]  )))))
#
#  point.in.hull<-sapply(1:length(sol), function(k)
#    geometry::inhulln(geometry::convhulln(sol[[k]]),matrix(c(y0[k,]),ncol=q) ))
#
return(valid.point)
})
it
roxyegen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxyegen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
## One instance
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
funs=lm_multi()
sol<-conformal.multidim.jackplus.hull(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.05)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
valid.point
sol
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
q<-ncol(y)
B=100
funs=lm_multi()
sol<-conformal.multidim.msplit3(x,y, x0, train.fun = funs$train.fun,
predict.fun = funs$predict.fun, alpha=0.05,
split=NULL, seed=FALSE, randomized=FALSE,seed_rand=FALSE,
verbose=FALSE, rho=NULL,score = "max",
s_type = "st-dev",B=B,lambda=0,
tau = 1-(B+1)/(2*B),mad.train.fun = NULL,
mad.predict.fun = NULL)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
it<-pbapply::pbsapply(1:1, function(ss){
##
set.seed(ss^2)
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
q<-ncol(y)
B=100
funs=lm_multi()
sol<-conformal.multidim.msplit(x,y, x0, train.fun = funs$train.fun,
predict.fun = funs$predict.fun, alpha=0.05,
split=NULL, seed=FALSE, randomized=FALSE,seed_rand=FALSE,
verbose=FALSE, rho=NULL,score = "max",
s_type = "st-dev",B=B,lambda=0,
tau = 1-(B+1)/(2*B),mad.train.fun = NULL,
mad.predict.fun = NULL)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
return(valid.point)
})
mean(it)
it<-pbapply::pbsapply(1:1, function(ss){
##
set.seed(ss^2)
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
q<-ncol(y)
B=100
funs=lm_multi()
sol<-conformal.multidim.msplit(x,y, x0, train.fun = funs$train.fun,
predict.fun = funs$predict.fun, alpha=0.05,
split=NULL, seed=FALSE, randomized=FALSE,seed.rand=FALSE,
verbose=FALSE, rho=NULL,score = "max",
s.type = "st-dev",B=B,lambda=0,
tau = 1-(B+1)/(2*B),mad.train.fun = NULL,
mad.predict.fun = NULL)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
return(valid.point)
})
mean(it)
sol<-conformal.multidim.msplit(x,y, x0, train.fun = funs$train.fun,
predict.fun = funs$predict.fun, alpha=0.05,
split=NULL, seed=FALSE, randomized=FALSE,seed.rand=FALSE,
verbose=FALSE, rho=NULL,score = "max",
s.type = "st-dev",B=B,lambda=0,
tau = 1-(B+1)/(2*B),mad.train.fun = NULL,
mad.predict.fun = NULL)
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
funs=lm_multi()
sol<-conformal.multidim.jackplus(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.05)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
valid.point
## Averaging multiple predictions
library(pbapply)
it<-pbapply::pbsapply(1:3, function(ss){
set.seed(ss^2)
n=1000
p=6
q=3
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
funs=lm_multi()
sol<-conformal.multidim.jackplus(x,y,x0,train.fun = funs$train.fun,
predict.fun = funs$predict.fun,alpha=0.05)
n0<-nrow(y0)
valid.point<-mean(sapply(1:n0,function(u) prod(sapply(1:q, function(j)
as.numeric(sol[[u]][1,j] <= y0[u,j] && sol[[u]][2,j] >= y0[u,j]  )))))
return(valid.point)
})
mean(it)
n = 200
n0 = 5
p = 9
mu = rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
my_grid <- seq(from=0,to=1,length.out=5)
u=c(5,8)
y=t(apply(mltvnorm3,1,function(x) x[1] + x[2]*cos(6*my_grid) + x[3]*sin(6*my_grid)))
x0 = mvtnorm::rmvnorm(n0, mu)
fun=mean_multi()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
n=1000
p=6
q=2
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
q<-ncol(y)
# n = 200
# n0 = 5
# p = 9
# mu = rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# my_grid <- seq(from=0,to=1,length.out=5)
# u=c(5,8)
# y=t(apply(mltvnorm3,1,function(x) x[1] + x[2]*cos(6*my_grid) + x[3]*sin(6*my_grid)))
# x0 = mvtnorm::rmvnorm(n0, mu)
fun=mean_multi()
#################################### FULL CONFORMAL
final.full=conformal.multidim.full(x, y, x0, fun$train.fun,
fun$predict.fun, score="l2",
num.grid.pts.dim=5, grid.factor=1.25,
verbose=FALSE)
ppp<-plot_multidim_full(final.full)
n=300
p=6
q=2
mu=rep(0,p)
x = mvtnorm::rmvnorm(n, mu)
beta<-sapply(1:q, function(k) c(mvtnorm::rmvnorm(1,mu)))
y = x%*%beta + t(mvtnorm::rmvnorm(q,1:n))
x0=x[ceiling(0.9*n):n,]
y0=y[ceiling(0.9*n):n,]
n0<-nrow(y0)
q<-ncol(y)
# n = 200
# n0 = 5
# p = 9
# mu = rep(0,p)
# x = mvtnorm::rmvnorm(n, mu)
# my_grid <- seq(from=0,to=1,length.out=5)
# u=c(5,8)
# y=t(apply(mltvnorm3,1,function(x) x[1] + x[2]*cos(6*my_grid) + x[3]*sin(6*my_grid)))
# x0 = mvtnorm::rmvnorm(n0, mu)
fun=mean_multi()
#################################### FULL CONFORMAL
final.full=conformal.multidim.full(x, y, x0, fun$train.fun,
fun$predict.fun, score="l2",
num.grid.pts.dim=5, grid.factor=1.25,
verbose=FALSE)
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
devtools::load_all(".")
# Run tests and examples
devtools::test()
# Check package as CRAN
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran"))
# Upgrade version number
usethis::use_version(which = c("patch", "minor", "major", "dev")[2])
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
# Run tests and examples
devtools::test()
# Check package as CRAN
rcmdcheck::rcmdcheck(args = c("--no-manual", "--as-cran"))
# Check content
# remotes::install_github("ThinkR-open/checkhelper")
checkhelper::find_missing_tags()
# Check spelling
# usethis::use_spell_check()
spelling::spell_check_package()
roxygen2::roxygenise()
# Check URL are correct
# remotes::install_github("r-lib/urlchecker")
urlchecker::url_check()
urlchecker::url_update()
# check on other distributions
# _rhub
devtools::check_rhub()
roxygen2::roxygenise()
# check on other distributions
# _rhub
devtools::check_rhub()
roxygen2::roxygenise()
# check on other distributions
# _rhub
devtools::check_rhub()
rhub::check_on_windows(check_args = "--force-multiarch")
rhub::check_on_solaris()
roxygen2::roxygenise()
# check on other distributions
# _rhub
devtools::check_rhub()
roxygen2::roxygenise()
# check on other distributions
# _rhub
devtools::check_rhub()
rhub::check_on_windows(check_args = "--force-multiarch")
rhub::check_on_solaris()
#checking package dependencies (2.5s)
#Package required but not available: 'glmnet' (MULTI)
# _win devel
devtools::check_win_devel()
# Check reverse dependencies
# remotes::install_github("r-lib/revdepcheck")
usethis::use_git_ignore("revdep/")
# Check reverse dependencies
# remotes::install_github("r-lib/revdepcheck")
usethis::use_git_ignore("revdep/")
usethis::use_build_ignore("revdep/")
devtools::revdep()
library(revdepcheck)
# In another session
id <- rstudioapi::terminalExecute("Rscript -e 'revdepcheck::revdep_check(num_workers = 4)'")
rstudioapi::terminalKill(id)
# See outputs
revdep_details(revdep = "conformalInference.fd")
revdep_summary()                 # table of results by package
revdep_report() # in revdep/
# Clean up when on CRAN
revdep_reset()
# In another session
id <- rstudioapi::terminalExecute("Rscript -e 'revdepcheck::revdep_check(num_workers = 4)'")
rstudioapi::terminalKill(id)
# See outputs
revdep_details(revdep = "conformalInference.fd")
revdep_summary()                 # table of results by package
revdep_report() # in revdep/
revdep_check()
# In another session
id <- rstudioapi::terminalExecute("Rscript -e 'revdepcheck::revdep_check(num_workers = 4)'")
# In another session
id <- rstudioapi::terminalExecute("Rscript -e 'revdepcheck::revdep_check(num_workers = 4)'")
rstudioapi::terminalKill(id)
# See outputs
revdep_details(revdep = "conformalInference.fd")
revdep_summary()                 # table of results by package
revdep_report() # in revdep/
# Clean up when on CRAN
revdep_reset()
# Add comments for CRAN
usethis::use_cran_comments(open = rlang::is_interactive())
